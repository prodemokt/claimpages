// Context fields
var tableset;
var toomany;
var startselection;
var tablekeys;
var selboxes;
var keyfield;
var binds;
var hasbinds;
var mselect;
var toomanystring;
var selected_callback
// hack field use by sortComparer
var curfield;

function installContext(tscontext)
{
   tableset = tscontext.tableset;
   toomany = tscontext.toomany;
   startselection = tscontext.startselection;
   tablekeys = tscontext.tablekeys;
   selboxes = tscontext.selboxes;
   keyfield = tscontext.keyfield;
   binds = tscontext.binds;
   hasbinds = tscontext.hasbinds;
   mselect = tscontext.mselect;
   toomanystring = tscontext.toomanystring;
   selected_callback = tscontext.selected_callback;
}

// added by Nagesh Polepally
function setValue(selbox, newso)
{
	var dim = newso.length ;
	var code ;
	
	var ary;
	if(dim == 2)
	{
		code = newso[1].value
		//alert("the value at the end is " + code);
		if(hasbinds){
			ary = binds[2] ;
		} else {
			ary = startselection[2]; //no need of this
		}
		//alert(ary);
		if(hasbinds)
			selbox.value = ary[code];
		else
			selbox.value = code;
	}
}

function setOptions(selbox, newso)
{
  var so = selbox.options
  var dim = newso.length;
  var oldsel = selbox.value;
  so.length=0;
  var i;
  var newi = 0;
  for(i = 0 ; i < dim ; i++)
  {
    var opt = newso[i];
    so.add(opt);
    if((newi == 0) && (oldsel == opt.value))
      newi = i;
  }
  if(newi == 0 && dim == 2)
    newi =1;
//  if(dim == 2)
//  selbox.disabled=true;
//  else
//    selbox.disabled=false;
	selbox.selectedIndex = newi;
}
/*
var fieldoptions = new Array(selboxes.length);
for(var i = 0 ; i < fieldoptions.length ; i++)
  fieldoptions[i] = new Array();

function getOption2(field,val)
{
  alert('hari');	
  var fos = fieldoptions[field];
  var opt = fos[val];
  if(opt == null)
  {
    var bindval;
//alert("getOption:" + val);
    if(hasbinds)
      bindval = binds[field][val];
    else
      bindval = val;
    opt = new Option(bindval,val);
    opt.setAttribute('title',bindval);
    alert(opt.title);
    fos[val] = opt;
  }
  return opt;
//return new Option(val,val);
}
*/
function getOption(field,val)
{
    var bindval;
    if(hasbinds)
      bindval = binds[field][val];
    else
      bindval = val;
  var opt = new Option(bindval,val);
  opt.setAttribute('title',bindval);
  return opt;
}


function countSelections(so)
{
  if(so == null) // cheat to stop this from displaying (so startselection doesnt need to be filled if not necessary)
    return -1;
  return so.length;
}
function setTooManyOptions(selbox)
{
    selbox.options.length=1;
    selbox.options[0] = new Option(toomanystring,"");
//    selbox.disabled=true;
}
function sortComparer(a,b)
{
  var x,y;
  if(hasbinds)
  {
    x = binds[curfield][a];
    y = binds[curfield][b];
  }
  else
  {
    x = a;
    y = b;
  }
//alert("x = " + x +", y = " + y +", (x>y) = " + (x>y) + ",(x<y)" + (x<y)); 
  //return (x>y);
  if(x < y) return -1;
  if(x > y) return 1;
  return 0;
    
}

function setSelections(selectset)
{
	//alert('in set selection');
	for(var k = 0 ; k < selectset.length ; k++)
  	{
		var so = selectset[k];
		var count = countSelections(so);
//alert(k+" has " + count );
  		var selbox = selboxes[k];
		if(count == -1)
    		setTooManyOptions(selbox);
		else
    	{
			var soptions = new Array(count+1);
			soptions[0] = new Option(mselect,"");
//  	soptions[0] = blankOption;
			curfield = k;
			//if(hasbinds) (Sorting of the Select Boxes: Nagesh Polepally : 16-05-2005)
    		so.sort(sortComparer);
	      	for(var i = 0 ; i < so.length ; i++)
			{
    			var val = so[i];
    			//alert('in for loop');
	    		soptions[i+1] = getOption(k,val);//new Option(val,val);
	    	}
			
	    	if(selbox.type == 'select-one'){ // this is for part_details.
				setOptions(selbox,soptions);
	    	}else{
				setValue(selbox,soptions);
	    	}
		}
		
//   alert("SET field " + k + " had " + count );
	}
}
function getSelectedView(tscontext,selection)
{
  var ts = tscontext.tablekeys;
  for(var i = 0 ; i < ts.length ; i++)
  {
    if(ts[i] == selection)
    {
      return tscontext.tableset[i]; 
    }
  }
//alert("failed to find :" + selection)
}

function goStartSelection(tscontext)
{
  if(typeof(clearCasualItem)=='function')
  	clearCasualItem();

  installContext(tscontext);
  _goStartSelection();
  keyfield.value = "";
}
function _goStartSelection()
{
  //alert('in start selection');	
  setSelections(startselection);
  for(var i = 0 ; i < selboxes.length ; i++)
    if(selboxes[i].type == 'select-one'){
		selboxes[i].selectedIndex = 0;
    }else{
		selboxes[i].value = "";
    }
  return false;
}
function calculateView()
{
//alert("calculateView");
  if(typeof(selboxes)=='undefined')
  	return;
  var view = new Array(selboxes.length);
  for(var i = 0 ; i < view.length; i++)
  {
  	if(typeof(selboxes[i])=='undefined'){
	 	return;
  	}
	 if(selboxes[i].type == 'select-one')
	 {
		 view[i] = selboxes[i].value;
		// alert(view[i] + " and the length is " + view[i].length);
	} else  {
	 	view[i] = getIndex(selboxes[i].value);
	}
  }
//  alert(view);
  
  _setView(view);
  
}

function setView(tscontext,view)
{
  installContext(tscontext);
  var views = new Array(selboxes.length);
  for(var i = 0 ; i < view.length; i++)
  { 
  	if(typeof(selboxes[i])=='undefined')
   		return;
	 if(selboxes[i].type == 'select-one')
	 {
		 views[i] = view[i];
	} else  {
 		views[i] = getIndex(view[i]);
	}
  }
   _setView(views);
}

function _setView(view)
{
  var nullcount = 0;
  for(var i = 0 ; i < view.length; i++)
  {
    if(view[i] == null || view[i].length == 0)
    {
      view[i] = null;
      nullcount++;
    }
  }
  if(nullcount == view.length)
  {
	_goStartSelection();
    return false;
  }
  keyfield.value = "";
//alert("go choices");
  var choiceset = calculate_choiceset(view);
//alert("go selectset");
  var selectset = calculate_selectset(choiceset,view);
//alert("go selectboxes");
  setSelections(selectset);
//alert("done "+choiceset.length);
  if(choiceset.length == 1)
    setChosenRow(choiceset[0]);
  else // auto selections may have reduce choice to 1... check for this
  {
    var view1 = new Array(selboxes.length);
    var nullCount = 0;
    for(var k = 0 ; k < view1.length; k++)
    {
      view1[k] = selboxes[k].value;
      if(view1[k] == null)
    	  nullCount++;
    }
    if(nullCount == 0)
    {
      var choiceset1 = calculate_choiceset(view1);
      //alert("all selected!"+choiceset.length);
      if(choiceset1.length==1)
        setChosenRow(choiceset1[0]);
    }

  }
  //alert("keyfield = " + keyfield.value);
}
function setChosenRow(row)
{
//alert("setChosenRow");
  var key;
  if(typeof(tablekeys) == "object")
    key = tablekeys[row];
  else
    key = row;
	//alert("The  key is set to " + key);
  keyfield.value = key;
//alert("setting keyfield to "+ key);
//alert("keyfield is "+ keyfield);
   if(typeof(selected_callback)!='undefined'){
   	selected_callback(key);
  }

}
function matchViewToRow(csview,row)
{
  var i;
  for(i = 0 ; i < csview.length ; i++)
  {
    var val = csview[i];
//alert("the length compare val" + val.length + " row " + row[i].length); 
    if(val == null)
      continue;
	if(hasbinds){
      if(val == row[i])
       continue;
	}else{
      if(val == row[i] || val.toUpperCase() == row[i])
       continue;
	 }
    return false;
  }
  return true;
}

function calculate_choiceset(csview)
{
  var i;
  var result = new Array();
  for(i = 0 ; i < tableset.length ; i++)
  {
    var row = tableset[i];
    if(matchViewToRow(csview,row))
    {
	  result.push(i);
     }
  }
  return result;
}
function calculate_selectset(choiceset,curview)
{
  var i,j;
  var dims = tableset[0].length;
  var result = new Array(dims);
  var resulthash = new Array(dims);
  for(i = 0 ; i < dims ; i++)
  {
    result[i] = new Array();
    resulthash[i] = new Object();
  }
  if(choiceset.length != 0)
  {
    for(i = 0 ; i < choiceset.length ; i++)
	{
		var row = choiceset[i];
	    var tsrow = tableset[row];
    	for(j = 0 ; j < dims ; j++ )
	    {
    	  var val = tsrow[j];
	      var reshashrow = resulthash[j];
    	  var resrow = result[j];
	      var old = reshashrow[val];
    	  if(old == null)
	      {
		  	var num = resrow.length;
	       	if(num  >= toomany)
    	    {
        	  if(((j >0) && (curview[j-1]==null)) ){ // abort!
	          continue;
        	  }
    	    //  alert("allow #1");
        	}
	        reshashrow[val] = val;
    	    resrow.push(val);
	      }
        }
	  }
  } else 
  {
  	for(var k = 0 ; k < dims ; k++ )
	{
      var val1 = curview[k];
	  var reshashrow1 = resulthash[k];
      var resrow1 = result[k];
	  var old1 = reshashrow1[val1];
      if(old1 == null)
	  {
	  	var num1 = resrow1.length;
	   	if(num1  >= toomany)
	    {
    	   if(((j >0) && (curview[j-1]==null)) ){ // abort!
	  		 continue;
    	   }
    	    //  alert("allow #1");
       	}
		if(val1 != null && val1.length != 0)
		{
			reshashrow1[val1] = val1;
		    resrow1.push(val1);
		} else {
			var startValues = startselection[k];
			for(i = 0; i < startValues.length; i++)
			{
				reshashrow1[i] = startValues[i];
			    resrow1.push(startValues[i]);
			}
		}
	  }
    }
 }
  
   // clear large rows
  for(j = 0 ; j < dims ; j++ )
  {
    var resrow2 = result[j];
    var num2 = resrow2.length;
    //alert("row " + j + " + has " + num + "and the values " + resrow);
    if(num2 >= toomany)
    {
      if(((j >0) && (curview[j-1]==null)) ) // abort!
	  
        result[j] = null;
    }
  }
  return result;
}

function dump_ts_array(a)
{
  for(var i = 0 ; i < a.length ; i++)
  {
    var row = a[i];
    var tsrow = tableset[row];
    document.write("row="+row+"...");
    for(var j = 0 ; j < tsrow.length ; j++ )
    {
      document.write(tsrow[j]);
      document.write(",");
    }
    document.write("<br>\n");
  }
}
function dump_2D_array(a)
{
  var i,j;
  for(i = 0 ; i < a.length ; i++)
  {
    document.write("row ");
    document.write(i);
    document.write("..");
    var b = a[i];
    for(j = 0 ; j < b.length ; j++)
    {
      var x = b[j];
      document.write(x);
      document.write(",");
    }
    document.write("<br>");
  }
}
function dump(csview)
{
  //var i,j;
  var choiceset = calculate_choiceset(csview);
  dump_ts_array(choiceset);
  var selectset = calculate_selectset(choiceset,csview);
  dump_2D_array(selectset);
}

/////////////////////////////////////////////////////////////////////////////////////
// KEY SUPPORT JSCRIPT
/////////////////////////////////////////////////////////////////////////////////////
var keying = false;
function beginCalculateView(tscontext,field)
{
  //var key = window.event.keyCode;
  //if(!keying){
    installContext(tscontext);
	calculateView();
  //} 
  return true;
}
function isLetter(key)
{
  if(key >= 97 && key <= 122)
    return true;
  if(key >= 65 && key <= 90)
    return true;
  if(key == 38)
    return true;
  if(key == 40)
    return true; 
  return false;
}
function goEvent(field)
{
  var key = window.event.keyCode;
//alert("go keyp"); 
  if(isLetter(key))
  {
    keying = true;
    return;
  }
}
function losing(tscontext,field)
{
//alert("lose"); 
  if(keying)
  {
    keying = false;
    installContext(tscontext);
    calculateView();
  }
}
function getting(tscontext,field)
{
  if(keying)
  {
   
    keying = false;
    installContext(tscontext);
    calculateView();
  }
}

// Nagesh Polepally
function getIndex(fieldValue)
{
	var index ;
	var ary;
	if(hasbinds){
		ary = binds[2];
	} else {
		ary = startselection[2]; //this is not needed
	}
	for (i=0; i < ary.length; i++)
	{
		if (ary[i] == fieldValue.toUpperCase())
		{
			index = i  ;
			break ;
		}
	}
	if(hasbinds)
		return index ;
	else
		return fieldValue;
}
